// Problem 61: Cyclical figurate numbers
// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

// Type of Number	Formula	Sequence
// Triangle	 P3(n)=n(n+1)2
//  	1, 3, 6, 10, 15, ...
// Square	 P4(n)=n2
//  	1, 4, 9, 16, 25, ...
// Pentagonal	 P5(n)=n(3n−1)2
//  	1, 5, 12, 22, 35, ...
// Hexagonal	 P6(n)=n(2n−1)
//  	1, 6, 15, 28, 45, ...
// Heptagonal	 P7(n)=n(5n−3)2
//  	1, 7, 18, 34, 55, ...
// Octagonal	 P8(n)=n(3n−2)
//  	1, 8, 21, 40, 65, ...
// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

// The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
// Each polygonal type: triangle ( P3(127)=8128), square ( P4(91)=8281), and pentagonal ( P5(44)=2882 ), is represented by a different number in the set.
// This is the only set of 4-digit numbers with this property.
// Find the sum of all numbers in ordered sets of n cyclic 4-digit numbers for which each of the  P3 to  Pn+2 polygonal types, is represented by a different number in the set.

// fn  min-arg  return   max-arg   return
// P8  19       1045     58        9976
// P7  21       1071     63        9828
// P6  23       1035     70        9730
// P5  26       1001     81        9801
// P4  32       1024     99        9801
// P3  45       1035     140       9870

// PROBLEM UNSOLVED
// export function cyclicalFigurateNums(n) {
//   const polygonals = new Map();

//   for (let i = 3; i <= n + 2; ++i) {
//     const { polygonal, min, max } = pickPolygonal(i);
//     const polygonalNums = new Map();

//     for (let j = min; j <= max; ++j) {
//       const p = polygonal(j);
//       polygonalNums.set(p, p);
//     }

//     polygonals.set(i, polygonalNums);
//   }

//   console.log(createSet(1010, 9999, n, [], polygonals));
//   return true;
// }

// function createSet(start, end, n, arr, polygonals) {
//   if (n - arr.length === 1) {
//     // Last number in set is last two digits of previous number
//     // And first two digits of first number in set
//     const last = parseInt(arr[arr.length - 1].toString().slice(2));
//     const first = parseInt(arr[0].toString().slice(0, 2));
//     const lastNumberInSet = parseInt(last + "" + first);

//     arr.push(lastNumberInSet);

//     const types = getPolygonalTypes(arr, polygonals, n);

//     if (!types) {
//       arr.pop();
//       return;
//     }

//     const uniqueTypes = isUnique(types);

//     if (uniqueTypes) {
//       console.log(arr, "\n", types);
//       return arr;
//     }

//     arr.pop();
//     return;
//   }

//   for (let i = start; i <= end; ++i) {
//     arr.push(i);

//     const nextStart = parseInt(i.toString().slice(2)) * 100;
//     const nextEnd = nextStart + 99;
//     const startsWithZero = nextStart.toString().length < 4;

//     if (startsWithZero) {
//       arr.pop();
//       continue;
//     }

//     createSet(nextStart, nextEnd, n, arr, polygonals);
//     arr.pop();
//   }
// }

// function isUnique(types) {
//   for (let i = 0; i < types.length; ++i) {
//     for (let j = i + 1; j < types.length; ++j) {
//       const [num1, type1] = types[i];
//       const [num2, type2] = types[j];

//       if (num1 === num2 || type1 === type2) return false;
//     }
//   }

//   return true;
// }

// function getPolygonalTypes(arr, polygonals, n) {
//   const types = [];

//   for (let i = arr.length - 1; i >= 0; --i) {
//     let found = false;

//     for (let j = 3; j <= n + 2; ++j) {
//       const isInSet = polygonals.get(j).get(arr[i]);

//       if (isInSet) {
//         // console.log(type)
//         found = true;
//         types.push([isInSet, j]);
//       }
//     }

//     if (!found) return null;
//   }

//   return types;
// }

// function cyclicalFigurateNums(n) {
//   const polygonals = {};
//   const relation = {};

//   for (let i = 3; i <= n + 2; ++i) {
//     const { polygonal, min, max } = pickPolygonal(i);
//     const polygonalNums = [];

//     for (let j = min; j <= max; ++j) {
//       const p = polygonal(j);
//       polygonalNums.push(p);
//     }

//     polygonals[i] = polygonalNums;
//   }

//   for (let i = 3; i <= n + 2; ++i) {
//     for (let j = 0; j < polygonals[i].length; ++j) {
//       const lastTwoDigits = polygonals[i][j] % 100;
//       const key = i + " " + polygonals[i][j];

//       relation[key] = [];

//       for (let k = 3; k <= n + 2; ++k) {
//         if (k === i) continue;

//         for (let l = 0; l < polygonals[k].length; ++l) {
//           const firstTwoDigits = parseInt(polygonals[k][l] / 100);

//           if (lastTwoDigits === firstTwoDigits) {
//             relation[key].push([k, polygonals[k][l]]);
//           }
//         }
//       }
//     }
//   }

//   const set = createSet(n, [], relation, Object.keys(relation)).reduce((acc, val) => {
//     const poly = parseInt(val.slice(2));

//     return acc + poly;
//   }, 0);

//   console.log(createSet(n, [], relation, Object.keys(relation)), set);
//   return set;
// }

// function createSet(n, arr, relation, keys) {
//   if (arr.length === n) {
//     for (let i = 0; i < arr.length; ++i) {
//       if (i === arr.length - 1) {
//         const x = arr.at(-1).slice(2);
//         const y = arr.at(0).slice(2);

//         const lastDigits = parseInt(Number(x)) % 100;
//         const firstDigits = parseInt(y / 100);

//         if (lastDigits === firstDigits) {
//           console.log(arr);
//           return arr;
//         }

//         arr.pop();
//         return;
//       }

//       const [type1, polygonal1] = arr[i].split(" ");
//       const [type2, polygonal2] = arr[i + 1].split(" ");

//       if (type1 == type2) break;

//       const lastNum = parseInt(polygonal1) % 100;
//       const firstNum = parseInt(polygonal2 / 100);

//       if (lastNum !== firstNum) break;
//     }

//     arr.pop();
//     return;
//   }

//   for (let i = 0; i < keys.length; ++i) {
//     const key = keys[i];

//     arr.push(key);

//     for (let j = 0; j < relation[key].length; ++j) {
//       if (relation[key].length < n - 1) break;

//       const r = createSet(n, arr, relation, [relation[key][j].join(" ")]);

//       if (r) return r;
//     }

//     arr.pop();
//   }
// }

// function pickPolygonal(n) {
//   switch (n) {
//     case 3:
//       return { polygonal: P3, min: 45, max: 140 };
//     case 4:
//       return { polygonal: P4, min: 32, max: 99 };
//     case 5:
//       return { polygonal: P5, min: 26, max: 81 };
//     case 6:
//       return { polygonal: P6, min: 23, max: 70 };
//     case 7:
//       return { polygonal: P7, min: 21, max: 63 };
//     case 8:
//       return { polygonal: P8, min: 19, max: 58 };
//   }
// }

// function P3(n) {
//   return (n * (n + 1)) / 2;
// }

// function P4(n) {
//   return n * n;
// }

// function P5(n) {
//   return (n * (3 * n - 1)) / 2;
// }

// function P6(n) {
//   return n * (2 * n - 1);
// }

// function P7(n) {
//   return (n * (5 * n - 3)) / 2;
// }

// function P8(n) {
//   return n * (3 * n - 2);
// }

