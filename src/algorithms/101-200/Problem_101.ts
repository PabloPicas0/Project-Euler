// Problem 101: Optimum polynomial
// If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.

// As an example, let us consider the sequence of cube numbers. This is defined by the generating function,  un=n3:1,8,27,64,125,216,…

// Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.

// We shall define  OP(k,n)
//   to be the  nth
//   term of the optimum polynomial generating function for the first k terms of a sequence. It should be clear that  OP(k,n)
//   will accurately generate the terms of the sequence for  n≤k
//  , and potentially the first incorrect term (FIT) will be  OP(k,k+1)
//  ; in which case we shall call it a bad OP (BOP).

// As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for  n≥2,OP(1,n)=u1
//  .

// Hence we obtain the following OPs for the cubic sequence:

// OP(1,n)=1OP(2,n)=7n−6OP(3,n)=6n2−11n+6OP(4,n)=n31,1,1,1,…1,8,15,…1,8,27,58,…1,8,27,64,125,…

// Clearly no BOPs exist for k ≥ 4. By considering the sum of FITs generated by the BOPs (indicated in  red
//   above), we obtain 1 + 15 + 58 = 74. Consider the following tenth degree polynomial generating function:

// un=1−n+n2−n3+n4−n5+n6−n7+n8−n9+n10

// Find the sum of FITs for the BOPs.

// This problem required some research
// See:
// https://en.wikipedia.org/wiki/Lagrange_polynomial

function optimumPolynomial() {
  const fits = [1];
  const sequence = [1];

  let n = 2;

  while (sequence.length < 10) {
    const un = 1 - n + n ** 2 - n ** 3 + n ** 4 - n ** 5 + n ** 6 - n ** 7 + n ** 8 - n ** 9 + n ** 10;
    sequence.push(un);

    let k = sequence.length - 1;

    const basisPolynomials = sequence
      .map((_, idx) => idx + 1)
      .map((_, j, arr) => (x: number) => {
        let prod = 1;

        for (let m = 0; m <= k; ++m) {
          if (m === j) continue;

          prod *= (x - arr[m]) / (arr[j] - arr[m]);
        }

        return prod;
      });

    const fit = Math.round(L(k + 2, k, basisPolynomials, sequence));
    fits.push(fit);

    ++n;
  }

  return fits.reduce((acc, n) => acc + n);
}

function L(x: number, k: number, l: ((x: number) => number)[], arr: number[]) {
  let sum = 0;

  for (let j = 0; j <= k; ++j) {
    sum += arr[j] * l[j](x);
  }

  return sum;
}
